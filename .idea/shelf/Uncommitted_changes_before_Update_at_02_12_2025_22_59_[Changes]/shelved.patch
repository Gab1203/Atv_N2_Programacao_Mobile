Index: app/src/main/java/com/example/mainactivity/RegistrarTrilhaActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.mainactivity;\r\n\r\nimport android.Manifest;\r\nimport android.annotation.SuppressLint;\r\nimport android.content.pm.PackageManager;\r\nimport android.graphics.Color;\r\nimport android.location.Location;\r\nimport android.os.Bundle;\r\nimport android.os.SystemClock;\r\nimport android.widget.Button;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.core.app.ActivityCompat;\r\nimport androidx.fragment.app.FragmentActivity;\r\n\r\nimport com.example.mainactivity.dao.PontoTrilhaDAO;\r\nimport com.example.mainactivity.dao.TrilhaDAO;\r\nimport com.example.mainactivity.dao.UsuarioDAO;\r\nimport com.example.mainactivity.model.PontoTrilha;\r\nimport com.example.mainactivity.model.Trilha;\r\nimport com.example.mainactivity.model.Usuario;\r\nimport com.google.android.gms.location.FusedLocationProviderClient;\r\nimport com.google.android.gms.location.LocationCallback;\r\nimport com.google.android.gms.location.LocationRequest;\r\nimport com.google.android.gms.location.LocationResult;\r\nimport com.google.android.gms.location.LocationServices;\r\nimport com.google.android.gms.maps.CameraUpdateFactory;\r\nimport com.google.android.gms.maps.GoogleMap;\r\nimport com.google.android.gms.maps.OnMapReadyCallback;\r\nimport com.google.android.gms.maps.SupportMapFragment;\r\nimport com.google.android.gms.maps.model.Circle;\r\nimport com.google.android.gms.maps.model.CircleOptions;\r\nimport com.google.android.gms.maps.model.LatLng;\r\nimport com.google.android.gms.maps.model.PolylineOptions;\r\nimport com.google.android.gms.maps.model.CameraPosition;\r\n\r\nimport android.content.SharedPreferences;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\n\r\npublic class RegistrarTrilhaActivity extends FragmentActivity implements OnMapReadyCallback {\r\n\r\n    private static final int REQ_LOCATION = 100;\r\n\r\n    private GoogleMap mMap;\r\n    private FusedLocationProviderClient locationClient;\r\n    private LocationCallback locationCallback;\r\n\r\n    private TextView txtVelocidade, txtDistancia, txtTempo, txtVelocidadeMax, txtKcal;\r\n    private Button btnIniciar, btnFinalizar;\r\n\r\n    private boolean trilhaIniciada = false;\r\n\r\n    private long trilhaId;\r\n    private Trilha trilha;\r\n    private TrilhaDAO trilhaDAO;\r\n    private PontoTrilhaDAO pontoDAO;\r\n    private Usuario usuario;\r\n\r\n    private Location ultimaLocation;\r\n    private double distanciaTotal = 0;\r\n    private double velocidadeMax = 0;\r\n    private Circle precisionCircle;\r\n\r\n    private long tempoInicio;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_registrar_trilha);\r\n\r\n        trilhaDAO = new TrilhaDAO(this);\r\n        pontoDAO = new PontoTrilhaDAO(this);\r\n\r\n        UsuarioDAO usuarioDAO = new UsuarioDAO(this);\r\n        usuario = usuarioDAO.buscarPrimeiroUsuario();\r\n\r\n        txtVelocidade = findViewById(R.id.txtVelocidade);\r\n        txtDistancia = findViewById(R.id.txtDistancia);\r\n        txtTempo = findViewById(R.id.txtTempo);\r\n        txtVelocidadeMax = findViewById(R.id.txtVelocidadeMax);\r\n        txtKcal = findViewById(R.id.txtKcal);\r\n\r\n        btnIniciar = findViewById(R.id.Startbutton);\r\n        btnFinalizar = findViewById(R.id.Stopbutton);\r\n\r\n        SupportMapFragment mapFragment = (SupportMapFragment)\r\n                getSupportFragmentManager().findFragmentById(R.id.map);\r\n        mapFragment.getMapAsync(this);\r\n\r\n        btnIniciar.setOnClickListener(v -> iniciarTrilha());\r\n        btnFinalizar.setOnClickListener(v -> finalizarTrilha());\r\n\r\n        btnIniciar.setEnabled(true);\r\n        btnFinalizar.setEnabled(false);\r\n\r\n        locationClient = LocationServices.getFusedLocationProviderClient(this);\r\n    }\r\n\r\n    private void iniciarTrilha() {\r\n        if (usuario == null) {\r\n            Toast.makeText(this, getString(R.string.configure_usuario_primeiro), Toast.LENGTH_LONG).show();\r\n            return;\r\n        }\r\n\r\n        btnIniciar.setEnabled(false);\r\n        btnFinalizar.setEnabled(true);\r\n        trilha = new Trilha();\r\n        trilha.setNome(\"Trilha \" + new SimpleDateFormat(\"HH:mm\", Locale.getDefault()).format(new Date()));\r\n        trilha.setDataInicio(dataAtual());\r\n        trilha.setHoraInicio(horaAtual());\r\n\r\n        trilhaId = trilhaDAO.inserirTrilha(trilha);\r\n\r\n        trilha.setId(trilhaId);\r\n\r\n        trilhaIniciada = true;\r\n        tempoInicio = SystemClock.elapsedRealtime();\r\n\r\n        iniciarLocalizacao();\r\n\r\n        Toast.makeText(this, getString(R.string.trilha_iniciada), Toast.LENGTH_SHORT).show();\r\n    }\r\n\r\n    private void finalizarTrilha() {\r\n        if (!trilhaIniciada) return;\r\n\r\n        trilhaIniciada = false;\r\n\r\n        trilha.setDataFim(dataAtual());\r\n        trilha.setHoraFim(horaAtual());\r\n        trilha.setDistanciaPercorrida(distanciaTotal);\r\n        trilha.setVelocidadeMaxima(velocidadeMax);\r\n\r\n        long timeElapsed = SystemClock.elapsedRealtime() - tempoInicio;\r\n        //Considera hora de pelo menos 1 milissegundo\r\n        double horas = (double) Math.max(timeElapsed, 1000) / (3600.0 * 1000.0);\r\n        double vm = (distanciaTotal / 1000.0) / horas;\r\n        trilha.setVelocidadeMedia(vm);\r\n\r\n        double kcal = calcularGastoCalorico(distanciaTotal, usuario.getPeso());\r\n        trilha.setGastoKcal(kcal);\r\n\r\n        trilhaDAO.atualizarTrilha(trilha);\r\n\r\n        Toast.makeText(this, getString(R.string.trilha_finalizada_salva), Toast.LENGTH_LONG).show();\r\n        finish();\r\n    }\r\n\r\n\r\n    private void iniciarLocalizacao() {\r\n        if (!temPermissao()) {\r\n            pedirPermissao();\r\n            return;\r\n        }\r\n\r\n        LocationRequest req = LocationRequest.create();\r\n        req.setInterval(1000);\r\n        req.setFastestInterval(500);\r\n        req.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);\r\n\r\n        locationCallback = new LocationCallback() {\r\n            @Override\r\n            public void onLocationResult(@NonNull LocationResult result) {\r\n                for (Location loc : result.getLocations()) {\r\n                    atualizarLocalizacao(loc);\r\n                }\r\n            }\r\n        };\r\n\r\n        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\r\n            // TODO: Consider calling\r\n            //    ActivityCompat#requestPermissions\r\n            // here to request the missing permissions, and then overriding\r\n            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\r\n            //                                          int[] grantResults)\r\n            // to handle the case where the user grants the permission. See the documentation\r\n            // for ActivityCompat#requestPermissions for more details.\r\n            return;\r\n        }\r\n        locationClient.requestLocationUpdates(req, locationCallback, getMainLooper());\r\n    }\r\n\r\n    private void atualizarLocalizacao(Location loc) {\r\n        if (loc == null || !trilhaIniciada) return;\r\n\r\n        LatLng pos = new LatLng(loc.getLatitude(), loc.getLongitude());\r\n        SharedPreferences prefs = getSharedPreferences(\"app_config\", MODE_PRIVATE);\r\n\r\n        String navMode = prefs.getString(\"navMode\", \"north_up\");\r\n        float zoom = 18f;\r\n        if (\"course_up\".equals(navMode) && ultimaLocation != null) {\r\n            float bearing = ultimaLocation.bearingTo(loc);\r\n            CameraPosition camPos = new CameraPosition.Builder()\r\n                    .target(pos)\r\n                    .zoom(zoom)\r\n                    .bearing(bearing)\r\n                    .tilt(0)\r\n                    .build();\r\n            mMap.animateCamera(CameraUpdateFactory.newCameraPosition(camPos));\r\n        } else {\r\n            CameraPosition camPos = new CameraPosition.Builder()\r\n                    .target(pos)\r\n                    .zoom(zoom)\r\n                    .bearing(0)\r\n                    .tilt(0)\r\n                    .build();\r\n            mMap.animateCamera(CameraUpdateFactory.newCameraPosition(camPos));\r\n        }\r\n\r\n        if (ultimaLocation != null) {\r\n            float d = ultimaLocation.distanceTo(loc); // metros\r\n            distanciaTotal += d;\r\n\r\n            double v = loc.getSpeed() * 3.6; // km/h\r\n            velocidadeMax = Math.max(velocidadeMax, v);\r\n\r\n            txtVelocidade.setText(String.format(Locale.getDefault(), \"%.1f km/h\", v));\r\n            txtDistancia.setText(String.format(Locale.getDefault(), \"%.2f m\", distanciaTotal));\r\n            txtVelocidadeMax.setText(String.format(Locale.getDefault(), \"%.1f km/h\", velocidadeMax));\r\n\r\n            long t = SystemClock.elapsedRealtime() - tempoInicio;\r\n            txtTempo.setText(formatarTempo(t));\r\n\r\n            double kcal = calcularGastoCalorico(distanciaTotal, usuario.getPeso());\r\n            txtKcal.setText(String.format(Locale.getDefault(), \"%.1f kcal\", kcal));\r\n        }\r\n\r\n        mMap.addPolyline(\r\n                new PolylineOptions().add(\r\n                                ultimaLocation == null ?\r\n                                        pos :\r\n                                        new LatLng(ultimaLocation.getLatitude(), ultimaLocation.getLongitude()),\r\n                                pos\r\n                        ).width(8)\r\n                        .color(Color.RED)\r\n        );\r\n\r\n        if (precisionCircle == null) {\r\n            CircleOptions circleOptions = new CircleOptions()\r\n                    .center(pos)\r\n                    .radius(loc.getAccuracy())\r\n                    .strokeWidth(2f);\r\n\r\n            precisionCircle = mMap.addCircle(circleOptions);\r\n        } else {\r\n            precisionCircle.setCenter(pos);\r\n            precisionCircle.setRadius(loc.getAccuracy());\r\n        }\r\n\r\n        pontoDAO.inserirPonto(trilhaId, new PontoTrilha(\r\n                loc.getLatitude(),\r\n                loc.getLongitude(),\r\n                loc.getSpeed(),\r\n                loc.getAccuracy(),\r\n                horaAtual()\r\n        ));\r\n\r\n        ultimaLocation = loc;\r\n    }\r\n\r\n    private String dataAtual() {\r\n        return new SimpleDateFormat(\"dd/MM/yyyy\", Locale.getDefault()).format(new Date());\r\n    }\r\n\r\n    private String horaAtual() {\r\n        return new SimpleDateFormat(\"HH:mm:ss\", Locale.getDefault()).format(new Date());\r\n    }\r\n\r\n    private String formatarTempo(long ms) {\r\n        int s = (int) (ms / 1000) % 60;\r\n        int m = (int) (ms / 60000) % 60;\r\n        int h = (int) (ms / 3600000);\r\n\r\n        return String.format(Locale.getDefault(), \"%02d:%02d:%02d\", h, m, s);\r\n    }\r\n\r\n    private double calcularGastoCalorico(double distanciaMetros, double pesoKg) {\r\n        double distanciaKm = distanciaMetros / 1000.0;\r\n        return distanciaKm * pesoKg * 0.7;\r\n    }\r\n\r\n    private boolean temPermissao() {\r\n        return ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)\r\n                == PackageManager.PERMISSION_GRANTED;\r\n    }\r\n\r\n    private void pedirPermissao() {\r\n        ActivityCompat.requestPermissions(\r\n                this,\r\n                new String[]{Manifest.permission.ACCESS_FINE_LOCATION},\r\n                REQ_LOCATION\r\n        );\r\n    }\r\n\r\n    @Override\r\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] p, @NonNull int[] g) {\r\n        super.onRequestPermissionsResult(requestCode, p, g);\r\n        if (requestCode == REQ_LOCATION && temPermissao()) {\r\n            iniciarLocalizacao();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onMapReady(@NonNull GoogleMap googleMap) {\r\n        mMap = googleMap;\r\n\r\n        SharedPreferences prefs = getSharedPreferences(\"app_config\", MODE_PRIVATE);\r\n        String mapType = prefs.getString(\"mapType\", \"vetorial\");\r\n        if (\"satellite\".equals(mapType)) {\r\n            mMap.setMapType(GoogleMap.MAP_TYPE_SATELLITE);\r\n        } else {\r\n            mMap.setMapType(GoogleMap.MAP_TYPE_NORMAL);\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/mainactivity/RegistrarTrilhaActivity.java b/app/src/main/java/com/example/mainactivity/RegistrarTrilhaActivity.java
--- a/app/src/main/java/com/example/mainactivity/RegistrarTrilhaActivity.java	(revision cac52ce4c1c31c8a5b31746db98910fdc75e5f6a)
+++ b/app/src/main/java/com/example/mainactivity/RegistrarTrilhaActivity.java	(date 1764726874764)
@@ -65,7 +65,7 @@
     private double distanciaTotal = 0;
     private double velocidadeMax = 0;
     private Circle precisionCircle;
-
+    private static final float Distancia_Minima_Para_Considerar = 2.5f;
     private long tempoInicio;
 
     @Override
@@ -137,8 +137,7 @@
         trilha.setVelocidadeMaxima(velocidadeMax);
 
         long timeElapsed = SystemClock.elapsedRealtime() - tempoInicio;
-        //Considera hora de pelo menos 1 milissegundo
-        double horas = (double) Math.max(timeElapsed, 1000) / (3600.0 * 1000.0);
+        double horas = (double)  timeElapsed / (3600.0 * 1000.0);
         double vm = (distanciaTotal / 1000.0) / horas;
         trilha.setVelocidadeMedia(vm);
 
@@ -214,7 +213,9 @@
 
         if (ultimaLocation != null) {
             float d = ultimaLocation.distanceTo(loc); // metros
-            distanciaTotal += d;
+
+            if(d >= Distancia_Minima_Para_Considerar)
+                distanciaTotal += d;
 
             double v = loc.getSpeed() * 3.6; // km/h
             velocidadeMax = Math.max(velocidadeMax, v);
